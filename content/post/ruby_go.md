+++
date = "2015-11-30T15:39:21+03:00"
draft = true
title = "Ruby и Go сидели на трубе"
tags = ["ruby", "go"]
slug = "ruby_go"
+++

# Ruby и Go сидели на трубе

В этой статье мы увидим как создать руби гем с native extension, основанным на Go, который я назвал [scatter](https://github.com/jondot/scatter), реализация которого стала возможна с выходом последнего релиза Go 1.5 с его новым режимом сборки c-shared.

## C Shared Libraries и Go, Ruby, Node.js, Python

С выходом Go 1.5 мы получили новенький, блестящий режим go build -buildmode=c-shared, с помощью которого можно создавать сишные динамические библиотеки.

Go, Ruby, Node.js и Python (как и многие другие) используют сишные библиотеки в качестве расширений. Например, если вам нужно распарсить XML и в вашем языке отсутствует соответствующий парсер (как бы сомнительно это ни звучало), или парсер попросту недостаточно быстрый, вы можете воспользоваться libxml - си библиотекой, которая существовала практически всегда (ну ладно, с 99-го).

И вот в чём собственно дело - Go 1.5 позволяет создавать библиотеки, подобные libxml, только на Go вместо C, а в последствии использовать их из любого языка который поддерживает си библиотеки.

Вот тут некто умудрился даже сделать [Firefox аддон](http://id-rsa.pub/post/go15-calling-go-shared-libs-from-firefox-addon/) на Go.

## Что такого полезного в связке Go и Ruby

Я не считаю руби медленным в каких-то общих случаях, но он может быть медленным в частных. Когда вы пытаетесь использовать для того, для чего он не предназначен, он может показать себя медленным.

С си библиотеками, а сейчас и Go - вы можете не переключаться с руби для решения подобных задач, когда это не имеет особого смысла.

## Ruby FFI и C Extensions
FFI очень прост в использовании в ruby если у вас уже есть правильно собранная библиотека на си.

Обычно вы бы использовали FFI для существующей, хорошо известной библиотеки и создавали бы для неё так называемый биндинг, точно так же как в [этих проектах](https://github.com/ffi/ffi/wiki/Projects-Using-FFI).

Итак, чтобы вызвать си код из ruby, для увеличения производительности или попросту чтобы [стать на плечи гигантов](https://ru.wikiquote.org/wiki/%D0%98%D1%81%D0%B0%D0%B0%D0%BA_%D0%9D%D1%8C%D1%8E%D1%82%D0%BE%D0%BD) мы должны:

- создать си библиотеку и экспортировать из неё функции для FFI или
- найти существующую библиотеку и указать FFI на её API

И, конечно же, используя Go 1.5
- создать Go библиотеку и представить её как C shared library, и указать FFI на её API

## Начинаем

Создание C shared library на Go очень просто, вот простой пример. Go часть:

```go
package main

import "C"

//export sq
func sq(num int) int {
    return num * num
}

func main() {}
```

Здесь комментарий export имеет значение и Go использует его чтоб отметить функции для экспорта. Создание C shared library выглядит как-то так:

```bash
$ go build -buildmode=c-shared -o libsq.so libsq.go
```

Теперь мы можем связать библиотеку с Ruby и FFI. Ruby часть:

```ruby
require 'ffi'
module Sq
  extend FFI::Library
  ffi_lib File.expand_path("main.so", File.dirname(__FILE__))
  attach_function :sq, [:int], :int
end

# test it out
puts Sq.sq(5)
```

С простейшим примером мы закончили. Вы обратили внимание насколько это было просто, и возможно у вас уже начали появляться тонны идей на этот счёт. Запишите их.

Но прежде чем вы начнёте их реализовывать, давайте посмотрим на расширенный, более практический пример.

## Scatter - Ruby гем для параллельных HTTP запросов, сделанный на Go

Scatter это демонстрационный гем, который делает запросы по списку URL-ов параллельно.

Для некоторых прагматичных целей (есть и другие реализации на Си) я решил делать такого рода работу с использованием HTTP-стэка Go с каналами и горутинами для конкурентной обработки.

### libscatter.go

Начнём, как и прежде, с создания c-shared библиотеки на Go. Напишем одну функцию, которая будет координировать все HTTP запросы.

```go
// где-то в функции scatter_request...
for _, uri := range cmd.URIs {
  go func(_uri string) {
    c <- makeRequest(_uri)
  }(uri)
}

result := Result{}
for _ := range cmd.URIs {
  resp := <-c
  result[resp.uri] = resp
}
```

Это ключевая идея. В этом примере мы не видим ни локов, ни сложной и грязной координации для достижения конкурентности.

## Грабли и паттерны

В простом `sq` примере ранее я использовал `int`ы в качестве параметров и возвращаемых значений. Я сделал это умышленно, дабы скрыть некоторые проблемы.

Вы можете захотеть передавать сложные объекты из Ruby в Go, например массивы, а потом соответсвенно вернуть несколько значений из Go обратно в Ruby, например идиоматичные для Go результат и ошибку.

`ruby-ffi` решает проблемы со сложными объектами за вас, но вот массивами не всегда, и если вы хотите вернуть несколько значений, то прийдется использовать объект (struct).

В нашем примере мы хотим:
- передавать много URLов, или даже varargs
- возвращать большой результат, представляющий собой аггрегацию всех реквестов
- сообщать об ошибке, если она произойдёт

К сожалению мы столкнёмся со всеми ранее упомянутыми проблемами работая с FFI. Мы должны создавать структуры вручную, мы должны ограничить размеры массивов для работы со встроенными массивами, или же нам прийдется работать с указателями и небезопасными ссылками.

## Останемся счастливыми

Я пока что хочу остаться в зоне счастья в контексте опыта разработки. Именно поэтому в этом примере мы переложим кодирование/декодирование параметров и возвращаемых значений на плечи кодека на стороне приложения.

Будем передавать строку туда, и принимать строку оттуда. Закодируем в JSON при передаче и раскодируем из JSON при получении, и это может с лёгкостью быть Protobuf, Thrift, msgpack или Avro - что вам больше нравится.

Запомните - это трюк, но не грязный. Он поможет вам добиться всего что вам нужно без лишней головной боли.

## Работаем со строками

Итак, строки становятся очень важными. А ведь и не удивительно - что бы мы ни делали, строки всегда были рабочими лошадками любого софта.

Но опять таки, я использовал очень простой пример. Я не использовал строки намеренно, потому как если вы попробуете сделать вот так:

```go
// libsq.go
package main
import "C"

//export prnt
func prnt(str string) {
  println(str)
}
```

Это не сработает.

Несмотря на то что всё будет выглядеть вроде-бы рабочим, строка будет пустая. Причина проста - Ruby строки немного не такие как Go строки. Для решения этой проблемы мы будем делать так:

```go
// libsq.go
package main
import "C"

//export prnt
func prnt(data *C.char) {
  println(C.GoString(data))
}
```

[Оригинал](http://blog.paracode.com/2015/08/28/ruby-and-go-sitting-in-a-tree/)
